Sys.time()
rm(list=ls())
graphics.off()
library(knitr)
library(vcfR) # for reading VCF
library(stringr) # for word (for VEP parsing)
library(tidyr) # for separate (for VEP parsing)
library(dplyr) # for renaming AC, AN and AF
base_folder="/Users/alexey/Documents/wecare/ampliseq/analysis4/s06_read_vcf_to_r"
opts_knit$set(root.dir = base_folder)
options(stringsAsFactors = F,
warnPartialMatchArgs = T,
warnPartialMatchAttr = T,
warnPartialMatchDollar = T)
#options(error = browser()) # Type Q or c to exit, drop browser level
# https://support.rstudio.com/hc/en-us/articles/200713843?version=1.1.456&mode=desktop
# https://stackoverflow.com/questions/13052522/how-to-leave-the-r-browser-mode-in-the-console-window/13052588
# Source VCF
vcf_file="/Users/alexey/Documents/wecare/ampliseq/analysis4/s04_annotated_vcf/ampliseq_nfe.vcf"
# Read vcf to vcfR object
vcfr <- read.vcfR(vcf_file)
# Clean-up
rm(vcf_file)
# Get data from header and fixed columns
meta_fix <- vcfR2tidy(vcfr, info_only=T)
# Get data frame with meta-information from vcf header
meta.df <- meta_fix$meta
dim(meta.df)
meta.df
# Get data frame with fixed columns (including parsed INFO, convert tibble to data-frame)
fixed.df <- as.data.frame(meta_fix$fix)
dim(fixed.df)
colnames(fixed.df)
# Rename AC, AN and AF to avoid interference with AF field in VEP annotations
fixed.df <- fixed.df %>%
rename(init_AC = AC, init_AN = AN, init_AF = AF)
# Note fixed=T in strsplit: otherwise it would interpreted split as regex
vep_fields <- as.character(meta.df[meta.df$ID=="ANN","Description"])
vep_fields <- word(vep_fields,-1) # requires stringr
vep_fields <- strsplit(vep_fields, "|", fixed=T)
vep_fields <- unlist(vep_fields)
vep_fields
# Split ANN/CSQ column
# Note \\ in sep: this is because the separator is interpreted as regex
fixed.df <- separate(fixed.df, "ANN", vep_fields, sep="\\|")
dim(fixed.df)
colnames(fixed.df)
fixed.df[1:5,1:7]
# Function to check for blanks in a vector
any_blank.udf <- function(x){any(x=="",na.rm=T)}
# Look up columns that contain blanks
x <- apply(fixed.df,2,any_blank.udf)
sum(x==T)
names(x[x==T]) # Most VEP fields
# Look at variants that contain blanks
y <- apply(fixed.df,1,any_blank.udf)
sum(y==T) # Each variant has a blank in at laest one field
# Recode blanks as NAs
NA -> fixed.df[fixed.df==""]
# Check for dots as NAs (empty Uploaded_variation field)
sum(fixed.df==".", na.rm=T)
# Clean-up
rm(any_blank.udf, x, y)
# Genotypes matrix with numeric representation of alleles
gt_num.mx <- extract.gt(vcfr) # original numeric codes: 0/1, 1/1 etc
dim(gt_num.mx)
gt_num.mx[1:5,6:10]
sum(is.na(gt_num.mx))
sum(!is.na(gt_num.mx))
sum(is.na(gt_num.mx))/sum(!is.na(gt_num.mx))
# Genotypes matrix with alleles coded as ACGT
gt_chr.mx <- extract.gt(vcfr, return.alleles = TRUE) # encoded as A/A, T/G etc
dim(gt_chr.mx)
gt_chr.mx[1:5,6:10]
NA -> gt_chr.mx[gt_chr.mx=="."]
gt_chr.mx[1:5,6:10]
sum(is.na(gt_num.mx))
sum(!is.na(gt_num.mx))
sum(is.na(gt_num.mx))/sum(!is.na(gt_num.mx))
sum(!is.na(gt_num.mx))
sum(is.na(gt_num.mx))/sum(nrow(gt_num.mx)*ncol(gt_num.mx))
sum(is.na(gt_chr.mx))
sum(!is.na(gt_chr.mx))
sum(is.na(gt_chr.mx))/sum(nrow(gt_chr.mx)*ncol(gt_chr.mx))
# dp
dp.mx <- extract.gt(vcfr, element = "DP", as.numeric = TRUE)
dim(dp.mx)
dp.mx[1:5,6:10]
sum(is.na(dp.mx))
sum(!is.na(dp.mx))
sum(is.na(dp.mx))/sum(nrow(dp.mx)*ncol(dp.mx))
sum(dp.mx==0)
sum(is.na(dp.mx), na.rm=T)
(sum(is.na(dp.mx)) + sum(dp.mx==0, na.rm=T) )/sum(nrow(dp.mx)*ncol(dp.mx))
(sum(is.na(dp.mx)) + sum(dp.mx==0, na.rm=T) )/ (nrow(dp.mx)*ncol(dp.mx))
sum(is.na(gt_chr.mx)) / (nrow(gt_chr.mx)*ncol(gt_chr.mx))
sum(is.na(gt_num.mx)) / (nrow(gt_num.mx)*ncol(gt_num.mx))
# gq
gq.mx <- extract.gt(vcfr, element = "GQ", as.numeric = TRUE)
dim(gq.mx)
gq.mx[1:5,6:10]
sum(gq.mx==0, na.rm=T)
sum(is.na(gq.mx))
(sum(is.na(gq.mx)) + sum(gq.mx==0, na.rm=T) ) / (nrow(dp.mx)*ncol(dp.mx))
(sum(is.na(gq.mx))) / (nrow(dp.mx)*ncol(dp.mx))
# ad
ad.mx <- extract.gt(vcfr, element = "AD")
dim(ad.mx)
ad.mx[1:5,6:10]
sum(ad.mx=="0,0", na.rm=T)
sum(is.na(ad.mx))
(sum(is.na(ad.mx))) / (nrow(ad.mx)*ncol(ad.mx))
sum(ad.mx=="0,0", na.rm=T) / (nrow(ad.mx)*ncol(ad.mx))
# Clean-up
rm(vcfr)
summary(as.factor(gt_num.mx))
summary(as.factor(gt_num.mx))
0 -> gt_add.mx[ gt_num.mx == "0/0" ]
gt_add.mx <- gt_num.mx
0 -> gt_add.mx[ gt_num.mx == "0/0" ]
1 -> gt_add.mx[ gt_num.mx == "1/0" ]
1 -> gt_add.mx[ gt_num.mx == "0/1" ]
2 -> gt_add.mx[ gt_num.mx == "1/1" ]
summary(as.factor(gt_add.mx))
gt_add.mx[1:5,6:10]
gt_add.mx <- matrix(as.numeric(gt_add.mx),nrow=nrow(gt_add.mx))
colnames(gt_num.mx) -> colnames(gt_add.mx)
rownames(gt_num.mx) -> rownames(gt_add.mx)
dim(gt_add.mx)
gt_add.mx[1:5,6:10]
ad.mx[1:5,6:10]
sum(is.na(ad.mx))
sum(ad.mx==".,.", na.rm=T)
sum(ad.mx==".,.", na.rm=T)
sum(is.na(ad.mx))
"./." -> ad.mx[is.na(ad.mx)]
sum(ad.mx==".,.", na.rm=T)
# Chunk 1: set_width
# eval=F
options(width = 999)
# https://stackoverflow.com/questions/36845178/width-of-r-code-chunk-output-in-rmarkdown-files-knitr-ed-to-html
# Chunk 2: start_section
Sys.time()
rm(list=ls())
graphics.off()
library(knitr)
library(vcfR) # for reading VCF
library(stringr) # for word (for VEP parsing)
library(tidyr) # for separate (for VEP parsing)
library(dplyr) # for renaming AC, AN and AF
base_folder="/Users/alexey/Documents/wecare/ampliseq/analysis4/s06_read_vcf_to_r"
opts_knit$set(root.dir = base_folder)
options(stringsAsFactors = F,
warnPartialMatchArgs = T,
warnPartialMatchAttr = T,
warnPartialMatchDollar = T)
#options(error = browser()) # Type Q or c to exit, drop browser level
# https://support.rstudio.com/hc/en-us/articles/200713843?version=1.1.456&mode=desktop
# https://stackoverflow.com/questions/13052522/how-to-leave-the-r-browser-mode-in-the-console-window/13052588
# Chunk 3: read_vcfr
# Source VCF
vcf_file="/Users/alexey/Documents/wecare/ampliseq/analysis4/s04_annotated_vcf/ampliseq_nfe.vcf"
# Read vcf to vcfR object
vcfr <- read.vcfR(vcf_file)
# Clean-up
rm(vcf_file)
# Chunk 4: extract_meta_and_fixed
# Get data from header and fixed columns
meta_fix <- vcfR2tidy(vcfr, info_only=T)
# Get data frame with meta-information from vcf header
meta.df <- meta_fix$meta
dim(meta.df)
meta.df
# Get data frame with fixed columns (including parsed INFO, convert tibble to data-frame)
fixed.df <- as.data.frame(meta_fix$fix)
dim(fixed.df)
colnames(fixed.df)
fixed.df[1:5,1:7]
# Clean-up
rm(meta_fix)
# Chunk 5
# Rename AC, AN and AF
fixed.df <- fixed.df %>%
rename(init_AC = AC, init_AN = AN, init_AF = AF)
# Chunk 6: tag_clinvar
fixed.df <- fixed.df %>%
rename(cv.ID = ID,
cv.ALLELEID = ALLELEID,
cv.CLNREVSTAT = CLNREVSTAT,
cv.CLNSIG = CLNSIG,
cv.CLNDN = CLNDN,
cv.CLNDISDB = CLNDISDB,
cv.CLNSIGCONF = CLNSIGCONF,
cv.SSR = SSR,
cv.CLNVI = CLNVI,
cv.ORIGIN = ORIGIN,
cv.GENEINFO = GENEINFO,
cv.CLNVCSO = CLNVCSO,
cv.CLNVC = CLNVC,
cv.MC = MC,
cv.RS = RS,
cv.CLNHGVS = CLNHGVS,
cv.DBVARID = DBVARID,
cv.AF_ESP = AF_ESP,
cv.AF_EXAC = AF_EXAC,
cv.AF_TGP = AF_TGP,
cv.CLNSIGINCL = CLNSIGINCL,
cv.CLNDNINCL = CLNDNINCL,
cv.CLNDISDBINCL = CLNDISDBINCL)
colnames(fixed.df)
# Chunk 7: extract_vep_annotation
# Note fixed=T in strsplit: otherwise it would interpreted split as regex
vep_fields <- as.character(meta.df[meta.df$ID=="ANN","Description"])
vep_fields <- word(vep_fields,-1) # requires stringr
vep_fields <- strsplit(vep_fields, "|", fixed=T)
vep_fields <- unlist(vep_fields)
vep_fields
# Split ANN/CSQ column
# Note \\ in sep: this is because the separator is interpreted as regex
fixed.df <- separate(fixed.df, "ANN", vep_fields, sep="\\|")
dim(fixed.df)
colnames(fixed.df)
fixed.df[1:5,1:7]
# Clean-up
rm(vep_fields)
# Chunk 8: check_blanks
# Function to check for blanks in a vector
any_blank.udf <- function(x){any(x=="",na.rm=T)}
# Look up columns that contain blanks
x <- apply(fixed.df,2,any_blank.udf)
sum(x==T)
names(x[x==T]) # Most VEP fields
# Look at variants that contain blanks
y <- apply(fixed.df,1,any_blank.udf)
sum(y==T) # Each variant has a blank in at laest one field
# Recode blanks as NAs
NA -> fixed.df[fixed.df==""]
# Check for dots as NAs (empty Uploaded_variation field)
sum(fixed.df==".", na.rm=T)
# Clean-up
rm(any_blank.udf, x, y)
# Chunk 9: extract_matrices
# Genotypes matrix with numeric representation of alleles
gt_num.mx <- extract.gt(vcfr) # original numeric codes: 0/1, 1/1 etc
dim(gt_num.mx)
gt_num.mx[1:5,6:10]
sum(is.na(gt_num.mx))
sum(!is.na(gt_num.mx))
sum(is.na(gt_num.mx)) / (nrow(gt_num.mx)*ncol(gt_num.mx))
# Genotypes matrix with alleles coded as ACGT
gt_chr.mx <- extract.gt(vcfr, return.alleles = TRUE) # encoded as A/A, T/G etc
dim(gt_chr.mx)
gt_chr.mx[1:5,6:10]
NA -> gt_chr.mx[gt_chr.mx=="."]
gt_chr.mx[1:5,6:10]
sum(is.na(gt_chr.mx))
sum(!is.na(gt_chr.mx))
sum(is.na(gt_chr.mx)) / (nrow(gt_chr.mx)*ncol(gt_chr.mx))
# dp - missed data are partially NAs and partially zeroes
dp.mx <- extract.gt(vcfr, element = "DP", as.numeric = TRUE)
dim(dp.mx)
dp.mx[1:5,6:10]
sum(dp.mx==0, na.rm=T)
sum(is.na(dp.mx))
( sum(is.na(dp.mx)) + sum(dp.mx==0, na.rm=T) ) / (nrow(dp.mx)*ncol(dp.mx))
# gq - some GQ are missed (= NA) and some genotypes are equivocal (GQ=0)
gq.mx <- extract.gt(vcfr, element = "GQ", as.numeric = TRUE)
dim(gq.mx)
gq.mx[1:5,6:10]
sum(gq.mx==0, na.rm=T)
sum(is.na(gq.mx))
sum(is.na(gq.mx)) / (nrow(gq.mx)*ncol(gq.mx))
# ad
ad.mx <- extract.gt(vcfr, element = "AD")
dim(ad.mx)
ad.mx[1:5,6:10]
sum(ad.mx=="0,0", na.rm=T)
sum(ad.mx==".,.", na.rm=T)
sum(is.na(ad.mx))
sum(ad.mx=="0,0", na.rm=T) / (nrow(ad.mx)*ncol(ad.mx))
# Clean-up
rm(vcfr)
# Chunk 10: add_gt
summary(as.factor(gt_num.mx))
gt_add.mx <- gt_num.mx
0 -> gt_add.mx[ gt_num.mx == "0/0" ]
1 -> gt_add.mx[ gt_num.mx == "1/0" ]
1 -> gt_add.mx[ gt_num.mx == "0/1" ]
2 -> gt_add.mx[ gt_num.mx == "1/1" ]
summary(as.factor(gt_add.mx))
gt_add.mx[1:5,6:10]
gt_add.mx <- matrix(as.numeric(gt_add.mx),nrow=nrow(gt_add.mx))
colnames(gt_num.mx) -> colnames(gt_add.mx)
rownames(gt_num.mx) -> rownames(gt_add.mx)
dim(gt_add.mx)
gt_add.mx[1:5,6:10]
ad.mx[1:5,6:10]
sum(ad.mx==".,.", na.rm=T)
sum(is.na(ad.mx))
".,." -> ad.mx[is.na(ad.mx)]
sum(ad.mx==".,.", na.rm=T)
ad <- unlist(strsplit(ad.mx,","))
sum(is.na(ad))
ref <- ad[seq(1,length(ad),2)]
alt <- ad[seq(2,length(ad),2)]
ref.mx <- matrix(as.integer(ref), nrow=nrow(ad.mx))
alt.mx <- matrix(as.integer(alt), nrow=nrow(ad.mx))
sum(ref) == "."
sum(ref == ".")
sum(alt == ".")
NA -> ref[ref=="."]
NA -> alt[alt=="."]
ref.mx <- matrix(as.integer(ref), nrow=nrow(ad.mx))
alt.mx <- matrix(as.integer(alt), nrow=nrow(ad.mx))
rownames(ref.mx) <- rownames(ad.mx)
colnames(ref.mx) <- colnames(ad.mx)
rownames(alt.mx) <- rownames(ad.mx)
colnames(alt.mx) <- colnames(ad.mx)
ref.mx[1:5,6:10]
alt.mx[1:5,6:10]
ad.mx[1:5,6:10]
gt_add.mx[1:5,6:10]
gq.mx[1:5,6:10]
rm(ad, ref, alt)
# Generate row names
row_names <- fixed.df$VarID
row_names[1:5]
colnames(fixed.df)
# Generate row names
row_names <- fixed.df$SplitVarID
row_names[1:5]
# Assign the rownames
row_names -> rownames(fixed.df)
row_names -> rownames(gt_add.mx)
row_names -> rownames(gt_num.mx)
row_names -> rownames(gt_chr.mx)
row_names -> rownames(dp.mx)
row_names -> rownames(gq.mx)
row_names -> rownames(ad.mx)
row_names -> rownames(ref.mx)
row_names -> rownames(alt.mx)
# Check
fixed.df[1:5,1:7]
gt_add.mx[1:5,6:10]
alt.mx[1:5,6:10]
# Clean-up
rm(row_names)
save.image(paste(base_folder, "s01_read_vcf_to_r.RData", sep="/"))
# Chunk 1: set_width
# eval=F
options(width = 999)
# https://stackoverflow.com/questions/36845178/width-of-r-code-chunk-output-in-rmarkdown-files-knitr-ed-to-html
# Chunk 2: start_section
Sys.time()
rm(list=ls())
graphics.off()
library(knitr)
library(vcfR) # for reading VCF
library(stringr) # for word (for VEP parsing)
library(tidyr) # for separate (for VEP parsing)
library(dplyr) # for renaming AC, AN and AF
base_folder="/Users/alexey/Documents/wecare/ampliseq/analysis4/s06_read_vcf_to_r"
opts_knit$set(root.dir = base_folder)
options(stringsAsFactors = F,
warnPartialMatchArgs = T,
warnPartialMatchAttr = T,
warnPartialMatchDollar = T)
#options(error = browser()) # Type Q or c to exit, drop browser level
# https://support.rstudio.com/hc/en-us/articles/200713843?version=1.1.456&mode=desktop
# https://stackoverflow.com/questions/13052522/how-to-leave-the-r-browser-mode-in-the-console-window/13052588
# Chunk 3: read_vcfr
# Source VCF
vcf_file="/Users/alexey/Documents/wecare/ampliseq/analysis4/s04_annotated_vcf/ampliseq_nfe.vcf"
# Read vcf to vcfR object
vcfr <- read.vcfR(vcf_file)
# Clean-up
rm(vcf_file)
# Chunk 4: extract_meta_and_fixed
# Get data from header and fixed columns
meta_fix <- vcfR2tidy(vcfr, info_only=T)
# Get data frame with meta-information from vcf header
meta.df <- meta_fix$meta
dim(meta.df)
meta.df
# Get data frame with fixed columns (including parsed INFO, convert tibble to data-frame)
fixed.df <- as.data.frame(meta_fix$fix)
dim(fixed.df)
colnames(fixed.df)
fixed.df[1:5,1:7]
# Clean-up
rm(meta_fix)
# Chunk 5
# Rename AC, AN and AF
fixed.df <- fixed.df %>%
rename(init_AC = AC, init_AN = AN, init_AF = AF)
# Note fixed=T in strsplit: otherwise it would interpreted split as regex
vep_fields <- as.character(meta.df[meta.df$ID=="ANN","Description"])
vep_fields <- word(vep_fields,-1) # requires stringr
vep_fields <- strsplit(vep_fields, "|", fixed=T)
vep_fields <- unlist(vep_fields)
vep_fields
# Split ANN/CSQ column
# Note \\ in sep: this is because the separator is interpreted as regex
fixed.df <- separate(fixed.df, "ANN", vep_fields, sep="\\|")
dim(fixed.df)
colnames(fixed.df)
fixed.df[1:5,1:7]
# Clean-up
rm(vep_fields)
?ppoints
Sys.time()
rm(list=ls())
graphics.off()
library(knitr)
library(vcfR) # for reading VCF
library(stringr) # for word (for VEP parsing)
library(tidyr) # for separate (for VEP parsing)
library(dplyr) # for renaming AC, AN and AF
base_folder="/Users/alexey/Documents/wecare/ampliseq/analysis4/s06_read_vcf_to_r"
opts_knit$set(root.dir = base_folder)
options(stringsAsFactors = F,
warnPartialMatchArgs = T,
warnPartialMatchAttr = T,
warnPartialMatchDollar = T)
#options(error = browser()) # Type Q or c to exit, drop browser level
# https://support.rstudio.com/hc/en-us/articles/200713843?version=1.1.456&mode=desktop
# https://stackoverflow.com/questions/13052522/how-to-leave-the-r-browser-mode-in-the-console-window/13052588
# Source VCF
vcf_file="/Users/alexey/Documents/wecare/ampliseq/analysis4/s04_annotated_vcf/ampliseq_nfe.vcf"
# Read vcf to vcfR object
vcfr <- read.vcfR(vcf_file)
# Clean-up
rm(vcf_file)
# Get data from header and fixed columns
meta_fix <- vcfR2tidy(vcfr, info_only=T)
# Get data frame with meta-information from vcf header
meta.df <- meta_fix$meta
dim(meta.df)
meta.df
# Get data frame with fixed columns (including parsed INFO, convert tibble to data-frame)
fixed.df <- as.data.frame(meta_fix$fix)
dim(fixed.df)
colnames(fixed.df)
fixed.df[1:5,1:7]
# Clean-up
rm(meta_fix)
summary(fixed.df$FILTER)
summary(as.factor(fixed.df$FILTER))
sort(summary(as.factor(fixed.df$FILTER)))
sort(summary(as.factor(fixed.df$FILTER)), decreasing = T)
sum(fixed.df$FILTER != "PASS")
Sys.time()
rm(list=ls())
graphics.off()
library(knitr)
library(vcfR) # for reading VCF
library(stringr) # for word (for VEP parsing)
library(tidyr) # for separate (for VEP parsing)
library(dplyr) # for renaming AC, AN and AF
base_folder="/Users/alexey/Documents/wecare/ampliseq/v04_ampliseq_nfe/s06_read_vcf_to_r"
opts_knit$set(root.dir = base_folder)
options(stringsAsFactors = F,
warnPartialMatchArgs = T,
warnPartialMatchAttr = T,
warnPartialMatchDollar = T)
#options(error = browser()) # Type Q or c to exit, drop browser level
# https://support.rstudio.com/hc/en-us/articles/200713843?version=1.1.456&mode=desktop
# https://stackoverflow.com/questions/13052522/how-to-leave-the-r-browser-mode-in-the-console-window/13052588
# Time stamp
Sys.time()
# Clenan-up
rm(list=ls())
graphics.off()
# Base folder
library(knitr)
base_folder="/Users/alexey/Documents/wecare/ampliseq/v04_ampliseq_nfe/s07_filter_genotypes_and_variants"
opts_knit$set(root.dir = base_folder)
options(stringsAsFactors = F,
warnPartialMatchArgs = T,
warnPartialMatchAttr = T,
warnPartialMatchDollar = T)
#setwd(base_folder)
data_folder="/Users/alexey/Documents/wecare/ampliseq/v04_ampliseq_nfe/s06_read_vcf_to_r"
load(paste(data_folder, "s01_read_vcf_to_r.RData", sep="/"))
base_folder="/Users/alexey/Documents/wecare/ampliseq/v04_ampliseq_nfe/s07_filter_genotypes_and_variants"
rm(data_folder, ad.mx)
x <- fixed.df$POS == 32914700
sum(x)
View(fixed.df[x,])
